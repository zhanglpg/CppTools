#ifndef __PARSE_PROTO_ARRARY_HPP
#define __PARSE_PROTO_ARRARY_HPP
#include <iostream>
#include <fstream>
#include <string>

namespace commonlibs {

	// T must be a protobuf object class generated by protobuf lib
template<class T>
class parse_proto_array {
public: 
	parse_proto_array() 
	{ }

	enum {cbuf_size = 65536} ;
	
	// return 0 if successful, otherwise -1 
	int get_one_package (std::istream & sbinary, T &sp) {
		static char cbuf[cbuf_size] ;
		char *pbuf = (char *) cbuf ;

		uint32_t size = 0 ;
		sbinary.read((char *) &size, sizeof(size));
		if(size > cbuf_size)  
		{
			std::cout << "Size= " <<size<< " too big" << std::endl ;
			return -1 ; 
		}

		if(size >cbuf_size) {
			std::cerr << "Message size too big.." << std::endl ;
			return -1 ;
		}

		::memset(pbuf,  0, size) ;
		sbinary.read(pbuf , size) ;
		//std::stringstream ss(std::string (pbuf, size)) ;
				
		std::cout << "size of package: " << size << std::endl ; 
		sp.Clear() ;
		if(size ==0 || !sp.ParseFromArray(pbuf, size))
		{
			std::cerr << "Parsing error !" << std::endl; 
			return -1 ;
		}
		return 0 ;
	}
	int parse_into_array(const std::string  &fname, std::vector<T> &v_sp ) 
	{
		v_sp.clear() ;

		
		std::ifstream ifs(fname.c_str(), std::ios_base::in | std::ios_base::binary) ;
		if(ifs.is_open()) {
			while(! ifs.eof()) 
			{
			
				T sp ;

				if(0 == get_one_package(ifs, sp)) 
					v_sp.push_back(sp) ;


			}
			return 0 ;
		}
		else 
			return -1 ;
	}
private: 
	
}; 
}

#endif 
